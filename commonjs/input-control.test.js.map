{"version":3,"sources":["../source/input-control.test.js"],"names":["describe","it","should","equal","expect","undefined","to","be","country","phone","deep","value","label","ZZ","result","text","template"],"mappings":"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","file":"input-control.test.js","sourcesContent":["import\n{\n\tgetPreSelectedCountry,\n\tgetCountrySelectOptions,\n\tparsePhoneNumberCharacter,\n\tformatPhoneNumber,\n\tparsePhoneNumber,\n\tgenerateNationalNumberDigits,\n\tmigrateParsedInputForNewCountry,\n\te164,\n\tgetCountryForParsedInput,\n\n\t// Private functions\n\tget_country_from_possibly_incomplete_international_phone_number,\n\tcompare_strings,\n\thas_international_option,\n\tstrip_country_calling_code,\n\tget_national_significant_number_part,\n\tcould_number_belong_to_country\n}\nfrom './input-control'\n\nimport { countries } from './countries'\n\nimport metadata from 'libphonenumber-js/metadata.min'\n\ndescribe('input-control', () =>\n{\n\tit('should get pre-selected country', () =>\n\t{\n\t\t// Can't return \"International\". Return the first country available.\n\t\tgetPreSelectedCountry({}, null, ['US', 'RU'], false, metadata).should.equal('US')\n\n\t\t// Can return \"International\".\n\t\t// Country can't be derived from the phone number.\n\t\texpect(getPreSelectedCountry({}, undefined, ['US', 'RU'], true, metadata)).to.be.undefined\n\n\t\t// Derive country from the phone number.\n\t\tgetPreSelectedCountry({ country: 'RU', phone: '8005553535' }, null, ['US', 'RU'], false, metadata).should.equal('RU')\n\n\t\t// Country derived from the phone number overrides the supplied one.\n\t\tgetPreSelectedCountry({ country: 'RU', phone: '8005553535' }, 'US', ['US', 'RU'], false, metadata).should.equal('RU')\n\t})\n\n\tit('should generate country select options', () =>\n\t{\n\t\t// Without custom country names.\n\t\tgetCountrySelectOptions(['US', 'RU'], null, false).should.deep.equal\n\t\t([{\n\t\t\tvalue : 'RU',\n\t\t\tlabel : 'Russia (Россия)'\n\t\t}, {\n\t\t\tvalue : 'US',\n\t\t\tlabel : 'United States'\n\t\t}])\n\n\t\t// With custom country names.\n\t\tgetCountrySelectOptions(['US', 'RU'], { 'RU': 'Russia' }, false).should.deep.equal\n\t\t([{\n\t\t\tvalue : 'RU',\n\t\t\tlabel : 'Russia'\n\t\t}, {\n\t\t\tvalue : 'US',\n\t\t\tlabel : 'United States'\n\t\t}])\n\n\t\t// With \"International\" (without custom country names).\n\t\tgetCountrySelectOptions(['US', 'RU'], null, true).should.deep.equal\n\t\t([{\n\t\t\tlabel : 'International'\n\t\t}, {\n\t\t\tvalue : 'RU',\n\t\t\tlabel : 'Russia (Россия)'\n\t\t}, {\n\t\t\tvalue : 'US',\n\t\t\tlabel : 'United States'\n\t\t}])\n\n\t\t// With \"International\" (with custom country names).\n\t\tgetCountrySelectOptions(['US', 'RU'], { 'RU': 'Russia', ZZ: 'Intl' }, true).should.deep.equal\n\t\t([{\n\t\t\tlabel : 'Intl'\n\t\t}, {\n\t\t\tvalue : 'RU',\n\t\t\tlabel : 'Russia'\n\t\t}, {\n\t\t\tvalue : 'US',\n\t\t\tlabel : 'United States'\n\t\t}])\n\t})\n\n\tit('should parse phone number character', () =>\n\t{\n\t\t// Accepts leading `+`.\n\t\tparsePhoneNumberCharacter('+').should.equal('+')\n\n\t\t// Doesn't accept non-leading `+`.\n\t\texpect(parsePhoneNumberCharacter('+', '+')).to.be.undefined\n\n\t\t// Parses digits.\n\t\tparsePhoneNumberCharacter('1').should.equal('1')\n\n\t\t// Parses non-European digits.\n\t\tparsePhoneNumberCharacter('٤').should.equal('4')\n\n\t\t// Dismisses other characters.\n\t\texpect(parsePhoneNumberCharacter('-')).to.be.undefined\n\t})\n\n\tit('should format parsed input value', () =>\n\t{\n\t\tlet result\n\n\t\t// National input.\n\t\tresult = formatPhoneNumber('880055535', 'RU', metadata)\n\t\tresult.text.should.equal('8 (800) 555-35')\n\t\tresult.template.should.equal('x (xxx) xxx-xx-xx')\n\n\t\t// International input, no country.\n\t\tresult = formatPhoneNumber('+780055535', null, metadata)\n\t\tresult.text.should.equal('+7 800 555 35')\n\t\tresult.template.should.equal('xx xxx xxx xx xx')\n\n\t\t// International input, with country.\n\t\tresult = formatPhoneNumber('+780055535', 'RU', metadata)\n\t\tresult.text.should.equal('+7 800 555 35')\n\t\tresult.template.should.equal('xx xxx xxx xx xx')\n\t})\n\n\tit('should parse phone numbers', () =>\n\t{\n\t\tparsePhoneNumber('+78005553535', metadata).should.deep.equal\n\t\t({\n\t\t\tcountry : 'RU',\n\t\t\tphone   : '8005553535'\n\t\t})\n\n\t\t// No `value` passed.\n\t\tparsePhoneNumber(null, metadata).should.deep.equal({})\n\t})\n\n\tit('should generate national number digits', () =>\n\t{\n\t\tgenerateNationalNumberDigits\n\t\t({\n\t\t\tcountry : 'FR',\n\t\t\tphone   : '509758351'\n\t\t},\n\t\tmetadata)\n\t\t.should.equal('0509758351')\n\t})\n\n\tit('should migrate parsed input for new country', () =>\n\t{\n\t\t// No input. Returns `undefined`.\n\t\tmigrateParsedInputForNewCountry('', 'RU', 'US', metadata).should.equal('')\n\n\t\t// Switching from \"International\" to a country\n\t\t// to which the phone number already belongs to.\n\t\t// No changes. Returns `undefined`.\n\t\tmigrateParsedInputForNewCountry('+18005553535', null, 'US', metadata).should.equal('+18005553535')\n\n\t\t// Switching between countries. National number. No changes.\n\t\tmigrateParsedInputForNewCountry('8005553535', 'RU', 'US', metadata).should.equal('8005553535')\n\n\t\t// Switching from \"International\" to a country.\n\t\tmigrateParsedInputForNewCountry('+78005553535', null, 'US', metadata).should.equal('+18005553535')\n\n\t\t// Switching countries. International number.\n\t\tmigrateParsedInputForNewCountry('+78005553535', 'RU', 'US', metadata).should.equal('+18005553535')\n\n\t\t// Switching countries. International number.\n\t\t// Country calling code is longer than the amount of digits available.\n\t\tmigrateParsedInputForNewCountry('+99', 'KG', 'US', metadata).should.equal('+1')\n\n\t\t// Switching countries. International number. No such country code.\n\t\tmigrateParsedInputForNewCountry('+99', 'KG', 'US', metadata).should.equal('+1')\n\n\t\t// Switching to \"International\". National number.\n\t\tmigrateParsedInputForNewCountry('8800555', 'RU', null, metadata).should.equal('+7800555')\n\n\t\t// Switching to \"International\". International number. No changes.\n\t\tmigrateParsedInputForNewCountry('+78005553535', 'RU', null, metadata).should.equal('+78005553535')\n\t})\n\n\tit('should format phone number in e164', () =>\n\t{\n\t\t// No number.\n\t\texpect(e164()).to.be.undefined\n\n\t\t// International number. Just a '+' sign.\n\t\texpect(e164('+')).to.be.undefined\n\n\t\t// International number.\n\t\te164('+7800').should.equal('+7800')\n\n\t\t// National number. Without country.\n\t\texpect(e164('8800', null)).to.be.undefined\n\n\t\t// National number. With country. Just national prefix.\n\t\texpect(e164('8', 'RU', metadata)).to.be.undefined\n\n\t\t// National number. With country. Just national prefix.\n\t\te164('8800', 'RU', metadata).should.equal('+7800')\n\t})\n\n\tit('should get country for parsed input', () =>\n\t{\n\t\t// Just a '+' sign.\n\t\tgetCountryForParsedInput('+', 'RU', ['US', 'RU'], true, metadata).should.equal('RU')\n\t\texpect(getCountryForParsedInput('+', undefined, ['US', 'RU'], true, metadata)).to.be.undefined\n\n\t\t// A country can be derived.\n\t\tgetCountryForParsedInput('+78005553535', undefined, ['US', 'RU'], true, metadata).should.equal('RU')\n\n\t\t// A country can't be derived yet.\n\t\t// And the currently selected country doesn't fit the number.\n\t\texpect(getCountryForParsedInput('+7', 'FR', ['FR', 'RU'], true, metadata)).to.be.undefined\n\t\texpect(getCountryForParsedInput('+7800', 'FR', ['FR', 'RU'], true, metadata)).to.be.undefined\n\n\t\t// A country can't be derived yet.\n\t\t// And the currently selected country doesn't fit the number.\n\t\t// Bit \"International\" option is not available.\n\t\tgetCountryForParsedInput('+7', 'FR', ['FR', 'RU'], false, metadata).should.equal('FR')\n\t\tgetCountryForParsedInput('+7800', 'FR', ['FR', 'RU'], false, metadata).should.equal('FR')\n\t})\n\n\tit('should get country from possibly incomplete international phone number', () =>\n\t{\n\t\t// `001` country calling code.\n\t\texpect(get_country_from_possibly_incomplete_international_phone_number('+800', metadata)).to.be.undefined\n\n\t\t// Country can be derived.\n\t\tget_country_from_possibly_incomplete_international_phone_number('+33', metadata).should.equal('FR')\n\n\t\t// Country can't be derived yet.\n\t\texpect(get_country_from_possibly_incomplete_international_phone_number('+7800', metadata)).to.be.undefined\n\t})\n\n\tit('should compare strings', () =>\n\t{\n\t\tcompare_strings('aa', 'ab').should.equal(-1)\n\t\tcompare_strings('aa', 'aa').should.equal(0)\n\t\tcompare_strings('aac', 'aab').should.equal(1)\n\t})\n\n\tit('should determine whether to show \"International\" option', () =>\n\t{\n\t\thas_international_option(['US', 'RU'], false).should.equal(false)\n\t\thas_international_option(['US', 'RU'], true).should.equal(true)\n\t\thas_international_option(['US', 'RU']).should.equal(false)\n\t\thas_international_option(countries).should.equal(true)\n\t})\n\n\tit('should strip country calling code from a number', () =>\n\t{\n\t\t// Number is longer than country calling code prefix.\n\t\tstrip_country_calling_code('+7800', 'RU', metadata).should.equal('800')\n\n\t\t// Number is shorter than (or equal to) country calling code prefix.\n\t\tstrip_country_calling_code('+3', 'FR', metadata).should.equal('')\n\n\t\t// `country` doesn't fit the actual `number`.\n\t\t// Iterates through all available country calling codes.\n\t\tstrip_country_calling_code('+7800', 'FR', metadata).should.equal('800')\n\n\t\t// No `country`.\n\t\t// And the calling code doesn't belong to any country.\n\t\tstrip_country_calling_code('+999', null, metadata).should.equal('')\n\t})\n\n\tit('should get national significant number part', () =>\n\t{\n\t\t// International number.\n\t\tget_national_significant_number_part('+7800555', null, metadata).should.equal('800555')\n\n\t\t// National number.\n\t\tget_national_significant_number_part('8800555', 'RU', metadata).should.equal('800555')\n\t})\n\n\tit('should determine of a number could belong to a country', () =>\n\t{\n\t\t// Matching.\n\t\tcould_number_belong_to_country('+7800', 'RU', metadata).should.equal(true)\n\n\t\t// First digit already not matching.\n\t\tcould_number_belong_to_country('+7800', 'FR', metadata).should.equal(false)\n\n\t\t// First digit matching, second - not matching.\n\t\tcould_number_belong_to_country('+33', 'AM', metadata).should.equal(false)\n\n\t\t// Number is shorter than country calling code.\n\t\tcould_number_belong_to_country('+99', 'KG', metadata).should.equal(true)\n\t})\n})"]}